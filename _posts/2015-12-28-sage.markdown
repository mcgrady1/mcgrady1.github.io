---
layout:     post
title:      "SAGE"
subtitle:   "Paper Summary"
date:       2014-05-06 12:00:00
author:     "Mcgrady"
header-img: "img/about-bg.jpg"
header-mask: 0.3
catalog:    true
tags:
    - Symbolic Execution
    - Smart Fuzzing
---

> 为了将符号执行引擎投入真实环境使用，微软的P.G团队开发了第一款基于二进制的符号执行引擎SAGE，也是至今为止唯一一款在实际生产中发挥重要作用的基于二进制文件的符号执行工具。
>
> 以下内容是在总结智能模糊测试章节时对SAGE的分析内容，仅供参考，请勿转载。

## 路径搜索算法

符号执行效率的最大制约因素就是路径爆炸问题--"Symbolically executing all feasible program paths does not scale to large programs. The number of feasible paths in a program grows exponentially with an increase in program size and can even be infinite in the case of programs with unbounded loop iterations."

因为使用符号执行技术对程序进行分析时，每一个分支语句都可能导致分析过程新增一条路径，所以探索路径的数量可能是按“指数级”增长的，加上程序中部分循环由符号变量控制，这也直接导致对程序路径的探索可能是无法终止的。因为以上原因，系统遍历一个大型应用程序的所有可达路径是不现实的，这也就是我们通常所说的路径爆炸问题。通过建立函数摘要避免函数内部代码展开的方法看似提高了程序测试时的代码覆盖率，缓解了路径爆炸问题，但这是以损失分析精度为前提的，同时，对于大型程序动辄上亿条指令的规模，即使使用函数摘要的方法，如果没有良好的路径搜索策略也是无法有效缓解路径爆炸问题的。

不完美的符号执行方法：使用符号执行技术对大型程序进行测试时，其分析精度很容易受到程序中复杂执行状态的影响（例如，指针操作，复杂的数学运算），另外测试程序对系统函数或者库函数的调用也是影响分析准确性的重要因素，总之当符号执行无法分析时就会采用实际值替换的方法使其继续进行下去，所以目前大部分的动态符号执行方法都使用了大量的简化操作，从全局分析被迫降低到局部符号分析，更严重的是，即使降低了分析精度要求，大部分方法也很难在有限的分析时间和费用成本下对大型程序进行系统完整的分析。正是因为这些原因，目前随机化的用例测试仍然是软件测试使用的主流方法。

#### 分代搜索算法

为了解决上面存在的问题SAGE的研究人员对搜索算法的设计提出几点要求：

- 其被设计用来系统的遍历大型程序的状态空间，需要能够处理大规模文件输入（可包含上千个符号变量）和足够深度的程序路径（百万级指令序列）
- 在避免用例冗余的情况下最大化从单次符号执行路径约束条件结果中生成的新测试用例
- 尽可能快的实现最大化代码覆盖率，但不同于其他的路径搜索策略，这里的最大化代码覆盖是以保证漏洞的快速挖掘为前提的（这里可以理解，因为代码覆盖率不是测试的目标，漏洞挖掘才是的）
- 对于路径探索中出现的背离问题是有容错性的，当背离出现时符号执行能够快速恢复正常状态并继续执行

动态符号执行中的**路径搜索背离**（divergence）问题：对于路径约束pc_0 = q1^q2^非q3生成的测试用例input_0，理想情况下，程序将input_0作为输入实际执行时应该先后经过谓词q1，q2，q3所在的条件分支，并探索q3未被遍历过的false分支。但在实际情况中，程序很可能按照q1，q2，qn所在的分支序列执行而背离了预期路径，这就是动态符号执行中的背离现象。为了检测背离问题的存在，可以在符号执行过程中使用一个向量记录程序实际执行时经过的分支，如果与input对应的预测执行向量不匹配则说明执行过程存在路径背离。

例：

```c
if(Is_int(x)){
    if(x>0){
        if(y>0) return false;
        if(x<100 & y<0) do something; 
        else do something;
    }
}
```

对上面的程序示例分析时，假设初始用例为x=80，y=-1，提取的对应的路径约束为PC=Is_int(x)^(x>0)^(x'<'100&y'<'0)，对最后一个约束取反求解得到x=80，y=1，执行预期是覆盖if(x'<'100 & y'<'0)条件的else分支，但实际执行时进入了if(y>0)分支，这就是路径搜索中的背离问题。

新的路径搜索算法分为两部分：

**路径搜索算法主流程**

![img](/img/in-post/post-sage/wpsF803.tmp.jpg)

上图中的算法是分代搜索的主流程。首次执行算法时先将初始用例inputseed放入工作集合序列worklist中（3行），以inputseed作为初始输入实际执行程序并检测inputseed是否触发了程序异常（4行）。

下面的while循环是算法的主体部分。当worklist中不为空时（5行），从worklist中选择第一个测试用例文件（6行），将其作为ExpandExecution函数的输入，根据其执行路径求解得到子测试用例集合childInputs（7行）。为了避免对程序块的冗余探索，对于新得到的测试用例集合，SAGE不会全部添加到worklist中。首先运行测试用例，监测其执行过程中的程序基本块覆盖信息，同时检查该用例是否能够触发异常（10行），然后使用Score函数根据用例的基本块覆盖信息对该用例进行评分（11行），并按照评分将用例插入到worklist列表中。

**路径扩展算法**

![img](/img/in-post/post-sage/wpsF814.tmp.jpg)      ![img](/img/in-post/post-sage/wpsF815.tmp.jpg)

上图中的ExpandExecution函数是分代搜索算法的核心，该算法的设计目标是以最快的速度竟可能多的覆盖指令代码块。首先将input作为符号输入对程序进行离线的符号执行操作（在下面的章节中会介绍什么是离线执行，这里可以简单的理解为符号执行运算），并生成对应的路径约束PC(4行)，PC是|PC|个约束条件的集合，其中每个约束条件对应程序执行路径上的一个条件分支语句，ExpandExecution算法设计的初衷就是改变深度或广度优先搜索一次只搜索一个分支的局限（或者只遍历一条路径的策略），而是一次性的对PC中的所有约束条件进行探索(6行)，正如上面右所示，对于PC中所有的约束进行相同的操作。首先对PC中第j个约束取反得到not(PC[j])，并和PC的前j个约束PC[0...(j-1)]合并成新的路径约束，如果其是可满足的则求得一组可行解I（6行），并生成新的测试用例newInput（7行），设置newInput的约束起始界限值(bound)为j（8行），并将newInput添加到新用例集合(childInputs)中（9行）。childInputs就是根据input得到的路径约束一次性求解得到的所有测试用例。整个过程就像是从父路径上的所有节点生出子路径，所以作者称其为代搜索。

![img](/img/in-post/post-sage/wpsF826.tmp.jpg)

​     对于上图中的测试程序，指定初始输入inputseed为good，inputseed.bound的初始值为0，经过第一层分代搜索后生成四个测试用例bood，gaod，godd和goo!，这四个用例是对good对应路径上的四个条件分支分别取反求解得到的。对整个执行树空间的遍历如下图所示，用例上方的数字是其生成时对应的分代搜索层数。

![img](/img/in-post/post-sage/wpsF827.tmp.jpg)

**算法中的难点**：

1）input.bound

​    ExpandExecution算法中bound变量的作用是什么呢，简单来说，为newInput设置bound变量，就是为了防止对其进行路径搜索时回溯newInput的父用例input已经遍历过的执行空间，生成冗余的测试用例，具体的理论证明可以查阅论文SCORE的解释。分代搜索策略加上bound变量的使用满足了第二条设计目标。

2）Score函数 

​    Score函数计算的是执行用例Newinput时新覆盖的程序基本块的数量（和其比较的是之前已经执行的所有用例覆盖过的程序基本块），举个例子，一个Newinput覆盖了100个新的程序基本块，则Score给其评分为100，后面会根据其分数将其插入worklist中。SAGE在下轮执行时会从worklist列表中选出评分最高的用例，这样就能保证每一轮都能够最大化的遍历未探索过的基本块。以上的设计使得分代搜索算法更好的满足了设计目标的第三条。

​    Score函数的设计还有效的解决了背离问题：

​    如果路径遍历时产生的分歧只是使探索方向偏离预期，但仍然能够正常的遍历未覆盖的程序模块，这其实不没有多大的负面影响，正如前面的用例所示。但是，通常情况下路径背离问题很可能阻止路径遍历算法向未探索的区域前进，陷入死循环。例如在深度优先搜索算法中，一个测试用例很可能使得执行路径未按照预期去探索p分支而是转向到之前已经探索过的p'分支，这会使下面的遍历在p至p'的路径中无限循环，这也是深度优先搜索时的常见问题。分代搜索算法则能对路径背离问题进行容错，并快速恢复到正常探索状态。因为每一轮分代搜索会生成大量的子用例对路径上的所有分支进行遍历，而不是类似于深度或者广度优先只生成一个用例对一个分支进行探索，当有一个用例在执行时出现了背离现象时，Score函数对其的评分就为0，SAGE能够马上感知到该用例为无效用例，从而避免将用例添加到worklist中，防止系统对其进行ExpandExecution操作，因此有效避免了背离问题对下面的探索过程的影响。Score函数的存在使得分代搜索算法满足了设计目标的第四条。

## SAGE系统

上面的路径搜索算法被实现于工具SAGE中。SAGE可以测试Windows系统下任意的文件读取程序，将输入文件中的每个字节分别符号化。SAGE的另外一个关键创新就是该系统的符号执行是基于程序执行路径上的x86指令序列（trace）进行离线分析的。下面就来说明这样的设计是怎样使得SAGE可以对大型应用程序进行分析的。

基于x86指令的设计思路相对与基于源代码级的分析方法，毫无疑问增加了分析的难度，作者如何解决遇到的问难也会在下面进行详细的介绍。针对大型应用程序作者还提出了一些至关重要的优化策略。

#### 系统架构

下面是SAGE的系统架构图

![img](/img/in-post/post-sage/wpsF828.tmp.jpg)

SAGE通过重复四个任务来实现分代搜索算法，这四个任务或者说是四个模块分别为Tester、Tracer、CoverageCollector、SymbolicExecutor。

Tester模块实现的是Run&Check函数的功能，使用一个测试用例作为输入对程序进行检测，监控其在执行过程中是否出现内存访问异常等错误导致程序崩溃。只有当该用例未触发任何错误时才对其进行剩下的处理步骤，否则记录该测试用例，并从未测试用例集合中选择新的用例进入Tester模块的执行。

Tracer模块将Tester传递来的测试用例作为输入，再次执行待测试程序，但不同于Tester的是，此次执行程序过程中需要记录程序的运行状态（log），这个log文件可以被剩下的分析模块用来重放程序运行过程，方便对程序进行离线分析。Tracer模块是基于iDNA开发的，可以对程序进行机器码级别的执行路径记录。

CoverageCollector模块重放程序执行记录，计算此次执行过程中基本块的覆盖情况。SAGE使用基本块覆盖信息来实现前面算法中提到的Score函数。

SymbolicExecutor模块实现了算法中的ExpandExecution函数，通过再次重放执行记录对程序进行符号执行分析，提取路径条件约束，并生成新的测试用例。

CoverageCollector和SymbolicExecutor模块都是基于执行记录重放框架TruScan实现的，TruScan可以使用iDNA记录的程序执行状态文件对程序运行过程进行重放，即让程序重复前面记录的执行过程，保证执行过程中的每一点都是一致的。TruScan提供的一些反汇编接口，符号表，输入输出监控等都为符号执行的实现提供了可能。

#### 技术核心

SAGE为什么要选择基于x86机器指令实现符号执行呢，主要有以下三点原因：

- 种类繁多的编程语言。基于源代码的分析需要针对不同的编程语言和语法进行对应的分析，有些甚至需要考虑到特定的编译器。对于新出现的语言如果要进行符号执行分析又要重复之前的工作，这样做是很浪费时间的。如果我们直接对机器码进行分析就可以屏蔽掉不同编程语言，编译器及编译平台对分析过程的影响，机器码的种类是非常少的。x86是由Intel推出的一种机器指令集，现在被广泛运用到PC端，Windows，linux等操作系统都是基于x86指令集的。
- 编译过程修改了程序的实际行为。在源代码中分析得到的软件漏洞可能只存在于编译前的阶段，编译器编译过程对指令做出的优化、代码混淆、基本块转换都可能是的编译前后的代码语义发生变化，直接导致实际产品根本就无法触发漏洞，而在源代码中未发现的漏洞因为程序编译而出现。基于机器指令的分析则可以确定是程序实际存在的漏洞。
- 软件代码未开源。大多数情况下，软件的源代码或者第三方链接库的代码都是无法获取的，及时测试和开发团队同属于一个公司也极有可能出现这样的情况。

基于以上原因SAGE选择基于x86机器指令直接进行分析。基于x86机器指令的符号执行过程又和基于源代码的有什么区别呢？基于源代码的路径约束条件可以通过if等条件分支直接提取，但在机器指令中又该通过什么方式提取约束呢，下面对这部分进行详细的说明。

**1）基于程序执行记录的离线分析******

在线的符号分析通常需要向程序源码中插入监控指令，或者借助动态插装工具（例如Nirvana或Valgrind（Catchconv就是使用了后者））进行分析。SAGE没有选择在线分析主要有两个原因：

1.一个程序中涉及大量的二进制程序组件，这些组件中的很大一部分可能是被操作系统保护（内核指令）或者是经过混淆的代码，通过静态或者动态插装都是很难分析这部分指令的。所以SAGE采取对全系统指令进行监控和重放的方法以解决这个问题。

2.大型程序中一些复杂路径很可能导致在线分析过程中约束表达的生成或提取发生错误，从而使得分析程序无法正常终止。同时在线分析的情况下我们也无法重现导致问题出现的路径执行情况，无法找到问题存在的根本原因。SAGE采用离线分析的方法，在程序执行记录重放的过程中采用控符号执行技术进行分析，通过监控分析结果输出我们就可以找到产生问题的路径和根本原因，帮助我们进一步完善SAGE。

**2）基于x86指令的符号执行技术******

1.约束生成

SAGE将程序执行过程使用到的所有与符号相关的内存地址都记录到映射表中，该表格记录了每个字节在内存中的地址和符号标签的对应关系。一个符号标签可以表示外部输入测试用例中的一个字节，或者是一些外部输入字节的表达式等。SAGE支持以下几种类型的符号标签：

- input(m) 表示测试用例的第m个字节
- c 表示一个常数
- t1 op t2 表示一些数学运算或者位运算的结果，op是操作码，t1和t2表示操作数
- 标签序列<t0...tn>当n=1时表示一个字大小的符号变量，当n=3时表示一个双字大小的变量
- 子标签<t,i>表示t符号变量中第i个字节

SAGE不支持对符号指针解引用的表示。

**指针解引用：******

int* ip = 100;
*ip;//这里就是指针解引用，对于符号指针，我们无法知道其具体指向了哪个地址，定义指针解引用也是没有意义的。 

**EFLAGS标记位******

SAGE使用程序执行记录重放进行符号分析，根据每分析一条指令的语义信息对符号变量与内存映射进行更新。除了分析符号变量的传递关系SAGE还需要对受符号变量影响的约束条件进行提取。例如当程序分析到一条由外部输入字节控制的条件跳转时，就会创建一个约束条件模型以记录当前的约束和在次条件跳转处执行的分支，最后将该约束模型添加到pc（路径约束）中。下面用一个简单的例子说明SAGE如何处理符号变量和约束条件的：
![img](/img/in-post/post-sage/wpsF838.tmp.jpg)
上面的x86指令片段中，首先使用系统调用从文件中读取10个字节，并将这10个字节放入一数组中，假设起始地址为1000，为了方便描述我们省略了具体的读取过程。文件读取及数组赋值完成后，SAGE为这10个字节所在的内存地址(1000~1009)创建对应的符号标签input(0)...input(9)。下面的两个mov指令执行的操作是将读入的第6个字节input(5)传递到al寄存器中。（1005这里表示数组第1005个字节地址的指针）在执行了这两条指令后，SAGE创建了一个新的映射关系，al-input(5)。上面代码的最后两条指令是对al寄存器中的值进行减一操作，并判断al-1后的值是否为0。两个指令执行完后，SAGE会添加一个新的符号变量，t = input(5) - 1，并为路径约束添加一个新的条件t = 0或者t != 0，如果程序在jz指令处跳转则选择t = 0，反之选择t != 0。

​    上面的例子看似简单，但实际上又引出了在处理x86指令流时的一个重要问题。上面的jz指令实际上判断的是eflages标记位中的zf位是否为1，而zf标记位受上面dec操作的直接影响，我们将指令的语义直译过来就是al-1 == 0为影响跳转的条件。但是如何建立从zf到符号变量之间的关系呢？ZF标记位属于一个特别的寄存器EFLAGS，其中包含了运行状态标记位例如CF,ZF,AF,PF,OF和ZF。这些位的状态完全由各类指令的运行结果决定。例如，EFLAGS的第一个标记位CF(进位标记位)，若算术操作产生的结果在最高有效位(most-significant bit)发生进位或借位则将其置1，反之清零。这个标志指示无符号整型运算的溢出状态，这个标志同样在多倍精度运算(multiple-precision arithmetic)中使用。第七个bit为ZF(零标志位）， 若前面指令的运算结果为0则将其置1，反之清零。除了通过运算指令会间接影响标志位，也可以通过sete和pushf等指令直接对EFLAGS寄存器进行赋值。

​    为了处理EFLAGS类似的寄存器，SAGE定义了一种bit级的符号向量描述方法，<f0...fn-1>描述了一个有n个bit位的符号变量。对于上面的例子，重放dec指令时，SAGE创建t = input(5) - 1的同时会将EFLAGS的cf和zf位与符号变量t建立关系（根据x86指令手册，dec操作只影响这两个标记位），后面无论是jz还是jc都能直接找到对应的和符号相关的约束表达式。

​    还有一个问题，如何确定约束条件对应的真值呢？当jz指令执行时我们无法知道约束条件对应的真值，SAGE根据跳转指令下一条执行的指令地址来进行判断。

**数据类型转换******

另外一个在x86指令中比较难处理的就是字节，字和双字数据对象的转换。可能大多数时候程序中不会有显式的转换过程，但还是有很多外部函数可以进行这样的操作，例如atol，malloc，memcpy函数等。SAGE通过子标签和序列标签来处理这个问题，用下面的用例来说明解决方法。
![img](/img/in-post/post-sage/wpsF839.tmp.jpg)
上面的这段指令中，假设前面的两条mov指令读取的内存地址对应的符号变量分别为t1和t2，执行后ch寄存器与t1建立映射关系，cl与t2建立映射关系。最后一条指令inc是对cx寄存器的操作，已知cx的高8位由ch表示，低8位由cl表示，所以在运算前SAGE首先将cx表示为序列符号<t1,t2>，inc操作后将新建一个符号标记t，其表示的是(<t1,t2>+1)，同时SAGE会更新ch和cl的符号表示为subtag(t,0)、subtag(t,1)。假设x=<x1，x2>，则x=x1+x2*256，x1=subtag(t,0)，x2=subtag(t,1)，可以看到通过序列标签和子标签就可以为不同长度的变量建立直观的表示方法和约束关系。

3）**约束优化**

为了提高符号执行效率和内存使用率，SAGE做出了很多的优化操作，这里只介绍其中公开的部分。

**子包含技术**

通过下面的例子来解释SAGE是如何实现子包含技术的

![img](/img/in-post/post-sage/wpsF83A.tmp.jpg)

上面的代码片段首先载入一个字节到cl寄存器中，并且在循环中对该值不断做减1操作，直到cl中值为0（ja 2中的2为指令序号，这里对应的就是dec cl这条指令）。假设载入到cl寄存器中的值对应的符号标签为t0，使用前面的分代搜索算法会生成下面的一系列约束条件，t1>0,...,tk-1>0,和tk<=0，其中k为载入字节的实际值，ti+1=ti-1，其中i属于{1...k}。符号执行上面的指令片段时，内存的消耗是呈线性增长的，因为每次循环都会生成一个新的变量和新的约束条件。

​    实际上，对于路径约束序列中的前k-2个约束是可以删除的，因为当最后两个约束(tk-1>0和tk<=0)成立的时候前面的k-2个显然成立。结合前面生成约束表达式和符号变量我们可以得到下面的表达式，tc-1 = tc-1 - 1 = .... = (t0-c)-1=t0-(c+1)，所以我们可以将路径约束化简为： t0-(k-1)>0和t0-k<=0 。这就是子包含技术，通过删除冗余的约束表达式一方面可以降低程序执行时的内存消耗，还可以提高路径遍历的效率。

为什么说提高了路径遍历效率呢？

读者不妨思考一下，使用前面介绍的分代搜索算法，对于优化前的路径约束条件pc=t1>0^...^tk-1>0^tk<=0需要生成k个新的测试用例，但其中k-2个都是冗余用例，在约束优化后只会生成两个新的测试用例，所以这对执行效率的影响是极大的。