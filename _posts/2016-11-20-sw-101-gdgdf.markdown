---
layout:     post
title:      "Compound File Binary File Format"
subtitle:   "复合文档格式研究"
date:       2016-11-20
author:     "Mcgrady"
header-img: "img/in-post/post-doc/wade.jpg"
header-mask: 0.3
catalog:    true
tags:
    - Reverse Engineering
    - File Format
---


> 复合文档（Compound Document）是一种不仅包含文本而且包括图形、电子表格数据、声音、视频图象以及其它信息的文档。可以把复合文档想象成一个所有者，它装着文本、图形以及多媒体信息如声音和图象。目前建立复合文档的趋势是使用面向对象技术，在这里，非标准信息如图像和声音可以作为独立的、自包含式对象包含在文档中。Microsoft Windows就是使用这种技术，叫做“OLE2 storage file format”或“Microsoft Office compatible storage file format”。Excel、Word等都是用这种格式存储的。
>
> 本文主要研究复合文档的二进制结构以及每个流中的数据结构描述。 

> 题外话：此文章是因为在对word进行fuzzing时没有头绪时所作，希望对doc或者复合文档格式感兴趣的同学有帮助。主要参考了微软官方[说明书](http://www.moon-soft.com/program/FORMAT/text/word8.htm#72)。



## 仓库与流 

复合文档的原理就像一个文件系统（文件系统：如FAT与NTFS）。复合文档将数据分成许多流（Streams），这些流又存储在不同的仓库（Storages）里。流和仓库的命名规则与文件系统相似，同一个仓库下的流及仓库不能重名，不同仓库下可以有同名的流。每个复合文档都有一个根仓库（root storage）。

##扇区与扇区链

#### 扇区与扇区标识

所有的流又分成更小的数据块，叫做数据扇区（sectors）。Sectors 可能包含控制数据或用户数据。整个文件由一个头（Header）结构以及其后的所有Sectors组成。Sectors的大小在头中确定，且每个Sectors的大小都相同。下面为示意图：

HEADER

SECTOR 0

SECTOR 1

┆

Sectors 简单的以其在文件中的顺序列举，一个扇区的索引（从0开始）叫做扇区标识（SID：sector identifier）。SID是一个有符号的32位的整型值。如果一个SID的值非负，就表示真正存在的那个Sector；如果为负，就表示特殊的含义。下表给出有效的特殊SID：

SID   Name                   Meaning                                           

–1   Free SID             空闲sector，可存在于文件中，但不是任何流的组成部分。

–2    End Of Chain SID      SID链的结束标记 (见2.2节)

–3   SAT SID                此Sector用于存放扇区配置表（SAT）(见4.2节)

–4   MSAT SID          此Sector用于存放主扇区配置表（MSAT）(见4.1节)

####扇区链与扇区标识链

用于存储流数据的所有Sectors的列表叫做扇区链（Sector Chain）。这些Sectors可以是无序的。因此用于指定一个流的Sectors的顺序的SID数组就称为SID chain。一个SID chain总是以End Of Chain SID（－2）为结束标记。

例：一个流由4个Sector组成，其SID链为[1, 6, 3, 5, –2]。

![img](http://p.blog.csdn.net/images/p_blog_csdn_net/liangjingbo/EntryImages/20080903/1633560621745458750.GIF)

流的SID链是通过扇区配置表构建的（见4.2节），但短流和以下两种内部流除外：

1．主扇区配置表，其从自身构建SID链（每个扇区包含下一个扇区的SID）。

2．扇区配置表，其通过主扇区配置表构建SID链。

##复合文档头

####复合文档头的内容 

复合文档头在文件的开始，且其大小必定为512字节。这意味着第一个Sector的开始相对文件的偏移量为512字节。复合文档头的结构如下：

Offset    Size        Contents                                           

0            8            复合文档文件标识：D0H CFH 11H E0H A1H B1H 1AH E1H

8            16          此文件的唯一标识(不重要, 可全部为0)

24          2            文件格式修订号 (一般为003EH)

26          2            文件格式版本号(一般为0003H)

28          2            字节顺序规则标识(见3.2):：FEH FFH = Little-Endian **or** FFH FEH = Big-Endian

30          2            复合文档中sector的大小(ssz)，以2的幂形式存储, sector实际大小为s_size = 2ssz 字节(一般为9即512字节, 最小值为7即128字节)

32          2            short-sector的大小(见5.1)，以2的幂形式存储, short-sector实际大

​                            小为s_s_size = 2sssz 字节(一般为6即64字节，最大为sector的大小)

34          10          Not used

44          4            用于存放扇区配置表（SAT）的sector总数

48          4            用于存放目录流的第一个sector的SID (见6)

52          4            Not used

56          4            标准流的最小大小(一般为4096 bytes), 小于此值的流即为短流。

60          4            用于存放短扇区配置表（SSAT）的第一个sector的SID (见5.2),

或为–2 (End Of Chain SID)如不存在。

64          4            用于存放短扇区配置表（SSAT）的sector总数

68          4            用于存放主扇区配置表（MSAT）的第一个sector的SID (见4.1),

或为–2 (End Of Chain SID) 若无附加的sectors。

72          4            用于存放主扇区配置表（MSAT）的sector总数

76          436        存放主扇区配置表（MSAT）的第一部分，包含109个SID。

####字节顺序（Byte Order）

文件数据的二进制存储有两种方法Little-Endian 和 Big-Endian，但实际应用中只使用Little-Endian方法即：低位8字节存放在地址的低位，高位8字节存放在地址的高位。

例：一个32位的整数13579BDFH（转为十进制即324508639），以Little-Endian存放为DFH 9BH 57H13H，以Big-Endian 存放为 13H 57H 9BH DFH。（H下标表示十六进制） 

##扇区配置

####主扇区配置表 

主扇区配置表（MSAT：master sector allocation table）是一个SID数组，指明了所有用于存放扇区配置表（SAT：sector allocation table）的sector的SID。MSAT的大小（SID个数）就等于存放SAT的sector数，在头中指明。MSAT的前109个SID也存放于头中，如果一个MSAT的SID数多余109个，那么多出来的SID将存放于sector中，头中已经指明了用于存放MSAT的第一个sector的SID。在用于存放MSAT的sector中的最后一个SID指向下一个用于存放MSAT的sector，如果没有下一个则为End Of Chain SID（-2）。

存放MSAT的sector的内容：（s_size表示sector的大小）

Offset            Size                   Contents                         

0                   s_size－4       MSAT的(s_size－4) / 4个SID的数组

s_size－4       4                   下一个用于存放MSAT的sector的SID，或－2（已为最后一个）

最后一个存放MSAT的sector可能未被完全填满，空闲的地方将被填上Free SID(-1)。

例：一个复合文档需要300个sector用于存放SAT，头中指定sector的大小为512字节，这说明一个sector可存放128个SID。MAST有300个SID，前109个放于头中，其余的191个将要占用2个sector来存放。此例假定第一个存放MSAT的sector为sector 1，则sector 1包含127个SID。第128个SID指向一个用于存放MSAT的sector，假定为sector 6，则sector 6包含剩下的64个SID（最后一个SID为－2，其他的值为－1）。

####扇区配置表 

扇区配置表（SAT：sector allocation table）是一个SID数组，包含所有用户流（短流除外）和内部控制流（the short-stream container stream, 见5.1, the short-sector allocation table, 见5.2, and the directory, 见7)的SID链。SAT的大小（SID个数）就等于复合文档中所存在的sector的个数。SAT的建立就是通过按顺序读取MSAT中指定的sector中的内容。

存放SAT的sector的内容：（s_size表示sector的大小）

Offset            Size               Contents                             

0                   s_size            SAT的s_size / 4个SID的数组

当通过SAT为一个流创建SID链时，SAT数组的当前位置（array index)表示的就是当前的sector，而该位置存放的SID则指向下一个sector。SAT可能在任意位置包含Free SID（－1），这些sector将不被流使用。如果该位置包含End Of Chain SID（－2）表示一个流的结束。如果sector用于存放SAT则为SAT SID（－3），同样用于存放MSAT则为MSAT SID（－4）。一个SID链的起点从用户流的目录入口（directory entry，见6.2节）或头（内部控制流）或目录流本身获得。

例：一个复合文档包含一个用于存放SAT的sector（sector 1）和2个流。

Sector 1的内容如下图：

![img](http://p.blog.csdn.net/images/p_blog_csdn_net/liangjingbo/EntryImages/20080903/2.GIF)

在位置1其值为－3，表明Sector 1是SAT的一部分。其中一个流为内部目录流，假定头中指定其开始为Sector 0，SAT中位置0的值为2，位置2的值为3，位置3 的值为－2。因此目录流的SID链为[0, 2, 3, –2]，即此目录流存放于3个sector中。目录中包含一个用户流的入口假定为sector 10，从图中可看出此流的SID链为[10, 6, 7, 8, 9, –2]。

##短流

####短流存放流

当一个流的大小小于指定的值（在头中指定），就称为短流(short-stream)。短流并不是直接使用sector存放数据，而是内含在一种特殊的内部控制流——短流存放流（short-stream container stream）中。短流存放流象其他的用户流一样：先从目录中的根仓库入口（root storage entry）获得第一个使用的sector，其SID链从SAT中获得。然后此流将其所占用的sectors分成short-sector，以便用来存放短流。此处也许较难理解，我们来打个比方：既然流组成符合文档，而短流组成短流存放流，这两者是相似的。把短流存放流当作复合文档，那么短流对应流，short-sector对应sector，唯一的不同是复合文档有一个头结构，而短流存放流没有。short-sector的大小在头中已经指定，因此可根据SID计算short-sector相对于短流存放流的偏移量（offset）。公式为：

short_s_pos(SID) = SID ∙ short_s_size = SID ∙ 2 sssz

例：sssz = 6 and SID = 5:

short_s_pos(SID) = SID ∙ 2 sssz = 5 ∙ 26 = 5 ∙ 64 = 320.

####短扇区配置表

短扇区配置表（SSAT：short-sector allocation table）是一个SID数组，包含所有短流的SID链。与SAT很相似。用于存放SSAT的第一个sector的SID在头中指定，其余的SID链从SAT中获得。存放SSAT的sector的内容：（s_size表示sector的大小）

Offset           Size               Contents                                   

0                   s_size            SSAT的s_size / 4个SID的数组

SSAT的用法与SAT类似，不同的是其SID链引用的是short-sector。

##目录

####目录结构

目录（directory）是一种内部控制流，由一系列目录入口（directory entry）组成。每一个目录入口都指向复合文档的一个仓库或流。目录入口以其在目录流中出现的顺序被列举，一个以0开始的目录入口索引称为目录入口标识(DID: directory entry identifier)。

如下图所示：

DIRECTORY ENTRY 0

DIRECTORY ENTRY 1

DIRECTORY ENTRY 2

DIRECTORY ENTRY 3

目录入口的位置不因其指向的仓库或流的存在与否而改变。如果一个仓库或流被删除了，其相应的目录入口就标记为空。在目录的开始有一个特殊的目录入口，叫做根仓库入口（root storage entry），其指向根仓库。目录将每个仓库的直接成员（仓库或流）放在一个独立的红黑树（red-black tree）中。红黑树是一种树状的数据结构，本文仅简单介绍一下，详细情况请参考有关资料。建构一个Red-Black tree的规则如下：

1. 每个节点（node）的颜色属性不是红就是黑。

2. 根节点一定是黑的。

3. 如果某个节点是红的，那它的子节点一定是黑的。

4. 从根节点到每个叶节点的路径（path）必须有相同数目的黑节点。

  ex:                 B               (用图形来解说第４点，从根节点

​                   /     /             到最底层的node，你会发现每个

​                  B       B            path都恰好有３个black node)

​                 / /    /   /        

​                B   B  R     B

​               /      / /   / /

​              R      B   B R   R

​                    / /

​                   R   R

注意并不总是执行上述规则。安全的方法是忽略节点的颜色。

例：以第一章中的图为例

1.根仓库入口描述根仓库，它不是任何仓库入口的成员，因此无需构建红黑树。

2.根仓库的所有直接成员(“Storage1”, “Storage2”, “Stream1”, “Stream2”, “Stream3”, 和 “Stream4”)将组成一棵红黑树，其根节点的DID存放于根仓库入口中。

3.仓库Storage1只有一个成员Stream1，Stream1构成一棵红黑树，此树只有一个节点。Storage1的目录入口包含Stream1的DID。

4. 仓库Storage2包含3个成员“Stream21”, “Stream22”, 和“Stream23”。这3个成员将构建一棵红黑树，其根节点的DID存放于Storage2的目录入口中。

这种存放规则将导致每个目录入口都包含3个DID：

1.在包含此目录入口的红黑树中，此目录入口的左节点的DID。

2.在包含此目录入口的红黑树中，此目录入口的右节点的DID。

3.若此目录入口表示一个仓库，则还包含此仓库的直接成员所组成的另一颗红黑树的根节点的DID。

在构建红黑树的过程中，一个节点究竟作为左还是右，是通过比较其名字来判断的。一个节点比另一个小是指其名字的长度更短，如长度一样，则逐字符比较。

规定：左节点<根节点<右节点。

####目录入口 

 一个目录入口的大小严格地为128字节，计算其相对目录流的偏移量的公式为：dir_entry_pos(DID) = DID ∙ 128。

目录入口的内容：

Offset    Size        Contents                                                  

0            64          此入口的名字（字符数组）, 一般为16位的Unicode字符,

以0结束。(因此最大长度为31个字符)

64          2            用于存放名字的区域的大小，包括结尾的0。

(如：一个名字右5个字符则此值为(5+1)∙2 = 12)

66          1            入口类型: 00H = Empty       03H = LockBytes (unknown)

01H = User storage       04H = Property (unknown)         02H = User stream 05H = Root storage

67          1            此入口的节点颜色: 00H = Red    01H = Black

68          4            其左节点的DID (若此入口为一个user storage or stream)    若没有左节点就为－1。

72          4            其右节点的DID (若此入口为一个user storage or stream)，    若没有右节点就为－1。

76          4            其成员红黑树的根节点的DID (若此入口为storage), 其他为－1。

80          16          唯一标识符（若为storage）(不重要, 可能全为0)

96          4            用户标记(不重要, 可能全为0)

100        8            创建此入口的时间标记。大多数情况都不写。

108        8            最后修改此入口的时间标记。大多数情况都不写。

116            4            若此为流的入口，指定流的第一个sector或short-sector的SID,若此为根仓库入口，指定短流存放流的第一个sector的SID,其他情况，为0。  120        4             若此为流的入口，指定流的大小（字节）若此为根仓库入口，指定短流存放流的大小（字节）其他情况，为0。

124        4            Not used  时间标记(time stamp) 是一个符号的64位的整数，表示从1601-01-01 00:00:00开始的时间值。



doc文档header
这部分的描述大家可能看的很多了，但是对于header之后的文本详细描述信息大家可能还一无所知，本文主要就是针对后面这部分稍显隐秘的内容进行介绍说明，附件中包含了分析使用的样本示例信息（大家有兴趣可以自己分析一下），以及一份doc文档详细格式描述（应该是官方出的）。

worddocument（mainstream）
该结构是.doc文件中的文本流信息，即完整的文本描述，以样本文件为例，在512的doc文件头之后就是document流，长度为34888，因为doc中数据块（sector）的大小单位在文件头中已经给出了定义，例如样例中是9，对应的大小为512，所以会在document之后进行填充到512的整数倍，即实际上该流是在35840处结束的。
这个文件的实际大小不符，显然图片是不在这个流中的。大家可能会奇怪在word读取doc的时候是怎样定位图片文件或者格式信息的。
首先说一下文本流中的编码形式，按照实例doc文件来说，其中的编码是ansi，两个字节描述一个字符，对于其中穿插的格式或者图片等媒体流也用两个字节进行描述。

上图是部分ascii码和样式的对应关系，0x00 0x01就用来表示当前位置是一个图片，文本中只有这样一个ascii码，也就是说文本中所有出现图片的地方对应的都是0x00 0x01，那文本又是如何找到该位置对应的图片的呢。为了说明这个问题，下面先看一下word文档中的其他结构。

第一次查看该文档请跳过该部分，直接进入datastream
该部分是在后面研究遇到瓶颈后重读官方文档后发现的，之前漏掉了：
Format of the Main Stream in a Complex File
FIB Stored at beginning of page 0 of the file. fib.fComplex is set to one. 

Text of body, footnotes, headers stored during last full save ，Text begins at the position recorded in fib.fcMin. 

FKPs for CHPs, PAPs and LVCs 
    The first Formatted Disk Page (FKP) begins at a 512-byte boundary after the last byte of text is written. The remaining FKPs are sequentially recorded in the 512-byte pages following the first FKP. The FKPs for Character Properties (CHPs), Paragraph Properties (PAPs), and LVCs are interleaved. Previous versions of Word wrote them in contiguous blocks. The hplcfbte’s of the three flavors (CHP, PAP and LVC) are used to find the relevant FKP of the appropriate type.
CHP, PAP and LVC的bte结构是为了辅助找到相关的FKP

Group of SEPXs stored during last full save 
SEPXs immediately follow the FKPs and are concatenated one after the other. 
Any text, stored during first fast save Any FKPs stored during first fast save 
Any SEPXs stored during first fast save Any text, stored during second fast save
Any FKPs stored during second fast save Any SEPXs stored during second fast save ...
Any text, stored during nth fast save 
Any FKPs stored during nth fast save 
Any SEPXs stored during nth fast save

（通过上面的对document流的结构描述也就明白了word是怎么对之前版本进行的记录和恢复（注意蓝色部分），所以不断修改的文件本身也会不断变化，这里是否有好的fuzzing策略呢？）
下面的图片识别部分中提到已经找到了sprmcpiclocation标记位是在stchpxfkps中出现的，那么这里的stchpxfkps结构又是做什么用的呢？

FKPS的作用：
In Word documents, the fundamental unit of text for which character exception information is kept is the run of exception text, a contiguous sequence of characters stored on disk that all have the same exception properties with respect to their underlying style character properties. Each run would have an entry recorded in a CHPX FKP. If a user never changed the character properties inherited from the styles used in the document and did a complete save of the document, although each of those styles may have different properties, the entire document stream would be one large run of exception text and one CHPX would suffice to describe the character properties of the entire document.
如果文件第一次保存之后就不再修改则文件中应该只会有一个大的chpxfkp结构来保存所有特性的入口。

The fundamental unit of text for which paragraph properties are recorded is the paragraph. Every paragraph has an entry recorded in a PAPX FKP.
每个段落都有对应的papx fkp结构来描述。

FKPs的结构：
首先先看一下相关的几个概念辅助理解
CP (Character Position): 
A four-byte integer specifying the position coordinate of a character of text within the logical text stream of a document.
制定了了一个特性在文档的逻辑文本流（为什么叫逻辑文本？）中的坐标。

FC( File Character position):
A four-byte integer which is the byte offset of a character (or other object) from the beginning of a stream of the .doc file. Before a file has been edited (i.e. in a full saved Word document), CPs can be transformed into FCs by adding the FC coordinate of the beginning of a document's text stream to the CP. After a file has been edited (i.e. in a fast-saved Word document), the mapping from CP to FC is recorded in the piece table。
FC是一个四字节的整数，指定了一个特性相对doc中一个stream的字节偏移。fc和cp是存在某种转换关系的，这种映射关系存储在piece table中。

FKP (Formatted disK Page): 
A data structure that fits in one 512-byte page that encodes either the character properties or the paragraph properties of a certain portion of a Word .doc file. An FKP consists of four components: 
1) a count of the number of runs or paragraphs described by the page. 
2) an array of FCs recorded in ascending order demarcating the boundaries between runs or paragraphs that are recorded adjacent to one another in the Word file. 
3) In character FKPs an array of offsets within the FKP in one to one correspondence with the array of FCs that locate the properties of the run that begins at a particular FC. 
In LVC FKPs an array of offsets within the FKP in 1-to-1 correspondence with the array of FCs that locate the LVCXs that describe the run that begins at a particular FC.
In paragraph FKPs an array of BX structures follows the array of FCs in 1 to 1 correspondence with the array of FCs. Each BX begins with an offset that locates the properties of the paragraph that begins at a particular FC. 
The remainder of the BX contains a PHE structure that encodes information about the height of the paragraph that begins at that FC.
4) a group of CHPXs if the FKP stores character properties, a group of PAPXs if the FKP stores paragraph and table properties, or a group of LVCXs if the FKP stores paragraph level and numbering cache information.
To find the CHPX/PAPX corresponding to a particular character in a document, calculate the FC coordinate for that character. Then search through the bin table for the type of property you want to produce, to find the FKP in the document stream whose array of FCs encompasses the FC of the document character. Then search within the FKP to find the index of the largest FC entry that is less than or equal to the FC of the document character. Use this index to look up an offset in the array of offsets (for character FKPs) or look up an offset in the array of BXs (for paragraph FKPs) within the FKP. Add this offset to the beginning address of the FKP in memory. This will be the first byte of the desired CHPX/PAPX.
FKP是一个512字节大小的结构体，是对doc文件中一个部分的chp或者pap特性的编码：

FKP结构中包含四部分：
1）crun是在结构的最后一个字节，即从511开始的一个字节，指定了该结构中包含的特性的数量，该fkp中的对应的是15个。
2）FKP结构的头部是一个FC结构的列表rgfc，用来区分相邻chp或者pap特性的界限（实际上应该就是这些结构的相对偏移，是否是相对worddocument流的呢？有待验证），但是为什么比crun对了一个16>15，仔细观察可以发现：

多出的那一个fc元素是下一个fkp结构fc列表开头的fc元素的值。
3）FC列表之后是一个列表，该列表与前面的FC列表一一对应，每个元素的大小为一字节。该列表总的元素的作用是定位每个chpx在FKP结构中的相对偏移。所以一个字节使足够的。
4）最后保存的是chpx列表如果对应的chpx想要保存在fkp结构中。
另外还有一点需要注意，rgb中可能会有几个元素指向同一个chpx，猜测应该是不同点共享同一个特性。

总结一下FKP的结构：


上面已经对FKP结构进行了详细的描述，那么word到底是怎样对图片进行定位的。（可以调回到之前的位置继续阅读了）

datastream
Format of the Data Stream
embedded objects-native data Word embedded object structures are sequentially concatenated if the document contains embedded objects.
huge PAPXs The grpprls from PAPXs which are too large to fit in an FKP are sequentially concatenated as necessary.
pictures Word picture structures are sequentially concatenated if the document contains pictures.
上面的描述说明了datastream中数据排列的限售顺序：
首先是内嵌对象数据，之前只在docx样本中分析国内前对象的情况，应该是cve-2014-xxxx，有时间转成doc分析一下。
接着是huge papx列表，下面有对该部分的介绍说明。
最后是pictures部分，如果文档中包含图片的话，word文档中的所有图片结构都是按照顺序在这段数据流中排列的。

实例分析
以附件中的样例文本为例，从35840处开始就是该文档的datastream
用offvis工具查看样本，以datastream为起始，偏移为0，紧接着的是一个长度为3861的数据是一个叫做Prcdata的结构，对应到官方说明中，这里应该是就是huge chpx（papx）结构的列表：（该样本不包含对象结构，所以没有嵌入对象数据）

huge CHPXs（papxs）
CHP：对文件中一些特性的描述性结构体，包括样式信息，图片等
（对应的还有一个叫做pap的结构：这是对文中段落属性的描述性结构体，为了方便介绍，大家暂时先把文中的chp和pap当成一回事）
但是在.doc文件中通常是不用CHP结构进行特性描述的，而是使用一个叫做CHPX的压缩结构，该结构实际保存的是一个特性相对于标准CHP结构的差别。
chpx由两部分组成：
1）cbgrpprl：也可简称为cb，是后面grpprl段的长度。
2）grpprl：是prl结构的列表或者叫数组，但是因为每个prl的长度不等，所以这里统称做列表。
prl结构中包含两部分：
1）sprm：sprm结构，就是表，图片等特性中相对chp原始结构具体做的一项改变。
A sprm is an instruction to modify one or more properties within one of the property defining data structures (CHP, PAP, TAP, SEP, or PIC).
2）operand：操作数。
简单来说，sprm是一个两字节的操作码，后面跟着操作数，通过这两个数据就可以对chp进行生成，因为要打开文件需要完整的chp，而doc中保存的都是压缩结构，所以这里看成是对结构的还原。

sprm两字节的长度中具体包含以上四项数据：
1.sgc定义了sprm的类型，到底是chp，pap还是pic类型的特性，说到这里上面需要修正一下，上面直接说是chpx是为了帮助理解，对于不同的特性都有对应的名称，例如pic（picture），chp（character），pap（paragraph）等。


2.ispmd是对应sgc组中结构中的属性编号，例如如果ispmd为22，则说明当前sprm对应的是sprmPFIntable结构。
3.spra是后面操作数的长度。

4.fspec是为了说明sprm是否需要特别的处理，例如对于文档中图片（从外部粘贴进文档）会用pic描述，这个fspec会置为1，说明需要到指定的位置区读取图片的详细数据流。

最后总结一下sprm，如上图所示：
0x2416是一个sprm结构的值，表示修改的是PAP基本结构中的FIntable属性，所需操作数是0或者1个字节。
一个chpx是对一个chp压缩版本的完整描述，通过chpx就可以对其进行生成还原操作。

下面是文本中一些属性的ascii 码及对应格式的描述，大家有兴趣可以对照样本格式进行验证：
Text
The text of the file starts at fib.fcMin and is usually set to the next 128 byte boundary after the end of the FIB. The text in a Word document is ASCII text with the following restrictions (ASCII codes given in decimal):
 Paragraph ends are stored as ASCII 13 (a single <Carriage Return> character). No other occurrences of this character sequence are allowed.
 Hard line breaks which are not paragraph ends are stored as ASCII 11. Other line break or word wrap information is not stored.
    Hyphens
     Breaking hyphens are stored as ASCII 45 (normal hyphen code).
     Non-required hyphens are ASCII 31.
     Non-breaking hyphens are stored as ASCII 30.
 Non-breaking spaces are stored as 160.
 Normal spaces are ASCII 32.
 Page breaks and Section marks are ASCII 12 (normal form feed); if there's an entry in the section table, it's a section mark, otherwise it's a page break.
 Column breaks are stored as ASCII 14.
 Tab characters are ASCII 9 (normal).
    Fields
     Field begin mark which delimits the beginning of a field is ASCII 19.
    
     Field end mark which delimits the end of a field is ASCII 21.
    
     Field separator ,which marks the boundary between the preceding field code text and following field expansion text within a field, is ASCII 20.
    
     Field escape character is the '\' character which also serves as the formula mark.
    
     The cell mark which delimits the end of a cell in a table row is stored as ASCII 7 and has the fInTable paragraph property set to fTrue (pap.fInTable==1).
    
     The row mark which delimits the end of a table row is stored as ASCII 7 and has the fInTable paragraph property and fTtp paragraph property set to fTrue (pap.fInTable==1 && pap.fTtp==1).红色字体部分就是我们前面提到的属性所具有的指示作用。

--------------------------------------------------------------------------------

按照官方说明，后面紧接着的部分应该就是图片数据流了：
PICTURE：
先看两端官方文档中关于图片识别的说明
图片及其识别结构在数据流中保存形式：
A picture is represented in the document text stream as a special character, an ASCII 1 whose CHP has the fSpec bit set to 1. The file location of the picture in the Word binary file is stored in the character's CHP in chp.fcPic. The fcPic is a byte offset into the data stream.
Beginning at the position recorded in chp.fcPic, a header data structure, the PIC, will be stored. If the picture is a reference to a TIFF file, a Picture file or an Office shape file, the name of the file is recorded immediately following the PIC in a Pascal style string.
Algorithm to determine the PIC of a picture in a complex file：
文本中的内容：判定复杂文本中图片的方法
The picture sprms contained in the prm's grpprl apply to any picture characters within the piece that have their chp.fSpec character ==fTrue. The picture properties for a picture (the PIC described in the Structure Definitions) are derived by fetching the PIC stored with the picture and applying to that PIC any picture sprms linked to the piece containing the picture special character.
图片判定条件：（经测试修改任何一项都会使当前位置的图片无法被解析）
当解析到文本的某个位置时，特性编码为1，且chp.fspec = true（1）并且能够连接到保存该图片的位置，即chp.fcpic变量中中保存了该图片数据流所在位置。
fcPic：4bytes，Offset in data stream pointing to beginning of a picture when character is a picture character (character is 0x01 and chp.fSpec is 1).
fcData：4bytes，Points to location of picture data, only if chp.fSpec is true.这应该才是图片在文本中的定位吧。

官方文当中除了上面的描述，信息似乎就断了，但是我们除了知道图片有对应的chp描述结构，数据流，并且数据流肯定在datastream中这些信息外，我们还是无法进行定位。在这里卡了很久，没什么头绪，后面想了一个折中的方法，既然知道datastream中存在图片数据流，我们假设图片在其中是以jpg或者png存储的，按照文件头进行搜索，先将样本中的六张图片进行定位。
通过上面的这种办法，运气比较好，确实定位了各图片所在的位置：这里需要注意一点，前面的huge chpxs的结尾偏移是0x9b15
9c28    ~   11C29   jpg格式
11d1d  ~   16E12   png格式     chpxfkp[7] - chpx[9]
16f06   ~   1A1FA  png格式     chpxfkp[8] - chpx[5]
1a2d2  ~   326f0    jpg格式      chpxfkp[8] - chpx[6]
327ff   ~   41156    jpg格式      chpxfkp[9] - chpx[0]
4127d  ~   6ff79     jpg格式      chpxfkp[9] - chpx[4]  
（有一些sprmCPiclocation的值为0，或者偏移在一个图片中间，这种不知道是什么情况，还需要研究）
从上面的数据可以看到各图片数据流中间是有间隔的，第一感觉chpx很可能是在这些间隔中，但是：
1）这些间隔的大小都不相同
2）对于图片特性的chpx目前还不知道长什么样，分析到这里又没有办法继续。

重新回到附件中的官方文档说明，搜索和picture相关的信息，查找头绪，搜索结果中看到下面的字段描述：

sprmCPicLocation (opcode 0x6A03) is used ONLY IN CHPX FKPs. This sprm moves the 4-byte operand of the sprm into the chp.fcPic field. It simultaneously sets chp.fSpec to 1.
还有一个标志位是：

大家还记得上面介绍的图片识别算法中提到的两个标记为嘛，就是fcpic和fspec，这两个标记位都有可能：
可能图片对应的chpx根本就不在图片数据流中，因为之前看过另外一篇文档，貌似文本中的所有格式描述信息应该都是顺序排放的，那我们就直接在文本中搜索0x6a03,因为样本文本中是大端，所以应该搜索的是0x03 0x6a
在偏移6ed7处找到一个，使用offvis查看：


下图中是对应的位置解析信息：


对应到sprmcpiclocation标记位的解析，后四位应该是图片的位置：
00 00 0f 15（这里的位置是相对datastream来说的吗？因为如果直接相对整个文件的偏移肯定是不对的）
因为datastream的起始为0x8c00，0x8c00+0x0f15=0x9b15

可以看到offvis对该处的颜色分界，说明这里应该是一个单独的结构描述的起始，还记得前面介绍过的hug papx结构吗，FF 00就是这个结构的终止处。
通过另外两个piclocation的值进行了验证，可以确定这个值应该就是相对datastream的偏移。但是第一张图片是从0x9c28处开始的，0x9b15~0x9c28又是社么样的描述性结构呢?这又回到了前面的问题，现在已经知道word定位图片，表格等属性的方法，但是图片间的间隔中到底是怎样描述性格式还是没有解决。

另外，这里sprmcpiclocation标记位所在的是worddocument中一个叫做FKP的结构，这个的作用是什么呢？
看到这里请跳转到worddocument部分红字之后的部分。

请接到这里继续往下看
查看该图片chpx中剩下的sprm属性（红色框中）好像也没有和图片位置相关的描述：

对比一下不同图片头的这段区域的差别：
下图为第一张图片和第四张图片前的结构：

 81 15 - 80 3f = d6 | 82 + 44 = c6 | 113 - c6 = 4d

85 0b - 84 6b = a0 | 4c + 44 = 90 | dd - 90 = 4d
下面两张为第二和第三章图片前的结构，都是png格式的：

51 e9 - 51 33 = b6 | 62 + 44 = a6 | F3 - a6 = 4d


 33 e2 - 33 2c = b6 62 + 44 = a6
可以看到前两个字节应该是和起始位置或者大小相关的一个整数。
后面的26个字节[“00 00 44 00 64”+21个“00”]（中间穿插了一个整数，第一章图对应的是08，第三章图对应的是0a）基本上都是一样的。
下面的结构相似度较低，但是从头部这30个字节可以每个图片前面的这部分一定是和图片相关的描述性结构体。

33 2c

回到官方文档中，还有两个和文档相关的结构没有分析过：

对照结构的描述和二进制文件，我个人感觉这里应该是Picture Descriptor结构体（对比前四个字节就可以更加肯定了）：

这里以第三张图片为例

1）lcb = 00 00 33 e2，这里应该就是图片的大小，第三张图片的起始位置是0x16e13，终止位置是0x1a1f4，两者之差就是33 e2。
2）cbheader应该是header的长度，无符号整数，两个字节，这里值为00 44 和 PIC header的0x44长度刚好对应上。   
下面的8个字节属于一个叫做METAFILEPICT的结构：
这些字段只有在后面是一个位图时才会有对应的描述，这里后面跟的是png图，所以x，y都为00，最后的一个是handle。


要理解METAFILEPICT这里又需要引入两个概念
Metafile: A collection of structures that can store an image in an application-independent format. The stored image can be recreated by processing the metafile structures. Also called a vector image, a metafile contains a sequence of drawing commands, object definitions, and configuration settings. The commands, objects, and settings recorded in a metafile can be used to render its contents on a display, output by a printer or plotter, stored in memory, or saved to a file or stream.
METAFILEPICT: A structure that defines the metafile picture format. METAFILEPICT is used for exchanging metafile data through the clipboard.

name value description
mfp.mm 00 64 The mapping mode in which the picture is drawn.
mfp.xext 00 00 The size of the metafile picture for all modes except the MM_ISOTROPIC and MM_ANISOTROPIC modes.
mfp.yext 00 00 The size of the metafile picture for all modes except the MM_ISOTROPIC and MM_ANISOTROPIC modes. 
mfp.hmf 00 00 A handle to a memory metafile.

后面的14个字节（0a 00 00 ......）可能是位图类型的一个描述，png位图对应的是0a（2,3），jpg对应的是08（1）

28偏移开始的应该是这个图像在水平方向上到达的范围
p28 = 0x1924
30偏移处是垂直方向上到达的范围
p30 = 0x088e
当图像被缩放的时候这两个变量会被忽略

32和34偏移处的两个字节，这里是和图像缩放相关的x轴和y轴的比例尺？

图像嵌入文件中如果有裁剪是通过36~44偏移的8个字节进行描述的。
44~62这18个字节使图片边框规范和整个图片的显示规范。
62~64这四个字节是图片原点的在x，y轴上的偏移量。
66偏移处的两个字节未使用。

68开始是一个rgb结构，可以看到这里已经不属于PIC header了，下面这部分结构的长度在文件头中并没有进行定义，这一段字节的含义又是什么？
PIC header unknown structure picture data

下面需要对unknown structure这部分的结构进行研究：
官方文档的附录部分有关于图片的一段话：
After reading the PICF structure from the picture data block, the reader should skip cbMETAHDR bytes (the size of a standard Windows metafile header). It should then compare the next cbWmfXBegin bytes in the picture data block against the bytes in the rgbWmfXBegin array above. If they do not match, the picture is a normal picture—Windows metafile, bitmap or TIFF.


WMF
Microsoft Windows Metafile (WMF) files are used to store vector and bitmap-format image data in memory or in disk files for later playback to an output device. 
Windows metafile header

格式的默认值和下面图片中的对应位置的值对应不起来：

红线处就是PIC header的结尾，下面按照描述应该是metafile header的开始，但是从第一个word的信息来说和描述是对应不上的
这里卡了很久，并没有跟任何已知的结构对应上，所以只能纯猜测分析：

0f 00 04 f0 应该是某个结构的起始标志，后面两个字节0x00 62，假设这是一个结构体的大小，用pic header+00 62 =a6
用picture data前区域的总大小减去这个长度，即f3 - a6 = 4d，下面我们需要判断是否每个图片前面都有一个大小为4d的固定区域，
对1,2,4三张图片进行了验证，都为4d，
在用这个数据对没有研究过的5,6两张图片进行研究，看是否能验证这个结果
第六张图

92 + 44 = d6
127c - 1159 = 123
123 - d6 = 4d
第五张图

44 + 6e = b2
27fe - 26ff = ff
ff - b2 = 4d
上面的两个图片验证了之前的结果，说明picture数据流之前的结构应该就是：
PIC header（0x44） unknown structure（0f 00 04 f0 length（word）...） unknown structure （length is 0x4d） picture data
另外在上面图片中标出的位置处应该就是图片在文本流中的顺序，图片是从0开始计数的。

